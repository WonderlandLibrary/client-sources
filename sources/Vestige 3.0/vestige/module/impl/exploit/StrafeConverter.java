package vestige.module.impl.exploit;

import lombok.Getter;
import lombok.Setter;
import net.minecraft.client.renderer.Tessellator;
import net.minecraft.client.renderer.WorldRenderer;
import net.minecraft.client.renderer.entity.RenderManager;
import net.minecraft.client.renderer.vertex.DefaultVertexFormats;
import net.minecraft.network.Packet;
import net.minecraft.network.play.client.*;
import net.minecraft.network.play.server.S08PacketPlayerPosLook;
import vestige.Vestige;
import vestige.event.Listener;
import vestige.event.Priority;
import vestige.event.impl.*;
import vestige.module.Category;
import vestige.module.Module;
import vestige.module.impl.combat.Killaura;
import vestige.module.impl.movement.Speed;
import vestige.setting.impl.BooleanSetting;
import vestige.setting.impl.ModeSetting;
import vestige.util.misc.LogUtil;
import vestige.util.network.PacketUtil;
import vestige.util.player.RotationsUtil;
import vestige.util.render.RenderUtil;

import java.util.ArrayList;
import java.util.concurrent.CopyOnWriteArrayList;

public class StrafeConverter extends Module {

    private final CopyOnWriteArrayList<Packet> packetsQueue = new CopyOnWriteArrayList<>();

    private Speed speedModule;
    private Killaura killauraModule;

    private double x, y, z, lastX, lastY, lastZ;

    private double lastGroundX, lastGroundY = -1, lastGroundZ;

    private final BooleanSetting allowHittingOffground = new BooleanSetting("Allow hitting offground", false);
    private final BooleanSetting updateOnVelocity = new BooleanSetting("Update on velocity", false);
    private final BooleanSetting noSprintSpoof = new BooleanSetting("No sprint spoof", false);
    private final ModeSetting renderMode = new ModeSetting("Render mode", "None", "None", "Box", "Line");

    private boolean wasSpeedEnabled;

    private ArrayList<Position> pastPositions = new ArrayList<>();

    public StrafeConverter() {
        super("Strafe Converter", Category.EXPLOIT);
        this.addSettings(allowHittingOffground, updateOnVelocity, noSprintSpoof, renderMode);
    }

    @Override
    public void onEnable() {
        wasSpeedEnabled = false;

        packetsQueue.clear();
    }

    @Override
    public void onDisable() {
        updatePosition();
    }

    @Override
    public void onClientStarted() {
        speedModule = Vestige.instance.getModuleManager().getModule(Speed.class);
        killauraModule = Vestige.instance.getModuleManager().getModule(Killaura.class);
    }

    @Listener(Priority.LOW)
    public void onReceive(PacketReceiveEvent event) {
        if(event.getPacket() instanceof S08PacketPlayerPosLook) {
            if(!packetsQueue.isEmpty()) {
                packetsQueue.stream().filter(p -> !(p instanceof C03PacketPlayer || p instanceof C0BPacketEntityAction)).forEach(p -> PacketUtil.sendPacketFinal(p));
                packetsQueue.clear();
            }

            if(speedModule.isEnabled()) {
                speedModule.setEnabled(false);
                wasSpeedEnabled = false;
                LogUtil.addChatMessage("Disabled speed due to server teleport.");
            }
        }
    }

    @Listener(Priority.LOW)
    public void onSend(PacketSendEvent event) {
        Packet packet = event.getPacket();

        if(mc.thePlayer == null || mc.thePlayer.ticksExisted < 20) {
            packetsQueue.clear();
        }

        if(speedModule.isEnabled()) {
            if(!event.isCancelled()) {
                boolean shouldNotCancel = allowHittingOffground.isEnabled() ? packet instanceof C0FPacketConfirmTransaction || packet instanceof C00PacketKeepAlive || packet instanceof C0APacketAnimation || packet instanceof C02PacketUseEntity : packet instanceof C0FPacketConfirmTransaction || packet instanceof C00PacketKeepAlive;

                if(!shouldNotCancel) {
                    event.setCancelled(true);
                    packetsQueue.add(event.getPacket());
                }
            }
        } else {
            this.updatePosition();
        }
    }

    @Listener(Priority.LOW)
    public void onUpdate(UpdateEvent event) {
        if(speedModule.isEnabled() && !wasSpeedEnabled && !mc.thePlayer.onGround) {
            speedModule.setEnabled(false);
            LogUtil.addChatMessage("Disabled speed : you must toggle it on ground to use it with strafe converter.");
        }

        if(!wasSpeedEnabled) {
            lastGroundX = mc.thePlayer.posX;
            lastGroundY = mc.thePlayer.posY;
            lastGroundZ = mc.thePlayer.posZ;
        }

        if(!speedModule.isEnabled() && wasSpeedEnabled) {
            this.updatePosition();

            pastPositions.clear();
        }

        boolean onGround = mc.thePlayer.onGround;

        if(onGround || updateOnVelocity.isEnabled()) {
            this.updatePosition();

            mc.thePlayer.onGround = onGround;

            lastGroundX = mc.thePlayer.posX;
            lastGroundY = mc.thePlayer.posY;
            lastGroundZ = mc.thePlayer.posZ;
        } else {
            x = mc.thePlayer.posX;
            y = mc.thePlayer.posY;
            z = mc.thePlayer.posZ;
        }

        wasSpeedEnabled = speedModule.isEnabled();
    }

    private void updatePosition() {
        if(!packetsQueue.isEmpty()) {
            if(speedModule == null) {
                speedModule = Vestige.instance.getModuleManager().getModule(Speed.class);
            }

            float direction = RotationsUtil.getRotationsToPosition(lastGroundX, lastGroundY, lastGroundZ, mc.thePlayer.posX, mc.thePlayer.posY, mc.thePlayer.posZ)[0];

            double totalDist = Math.hypot(mc.thePlayer.posX - lastGroundX, mc.thePlayer.posZ - lastGroundZ);

            int moveTicks = getMoveTicks();

            boolean shouldEdit = totalDist > 0;

            int moves = 0;

            mc.thePlayer.setPosition(lastGroundX, lastGroundY, lastGroundZ);

            double lastDist = 0;

            double traveledDist = 0;

            pastPositions.clear();

            for(Packet p : packetsQueue) {
                if(p instanceof C03PacketPlayer && shouldEdit) {
                    C03PacketPlayer packet = (C03PacketPlayer) p;

                    if(moves == 0) {
                        lastX = lastGroundX;
                        lastY = lastGroundY;
                        lastZ = lastGroundZ;
                    } else {
                        lastX = x;
                        lastY = y;
                        lastZ = z;
                    }

                    if(packet.isMoving()) {
                        x = packet.getX();
                        y = packet.getY();
                        z = packet.getZ();

                        double dist = Math.hypot(x - lastX, z - lastZ);

                        if(noSprintSpoof.isEnabled()) {
                            if(traveledDist > totalDist) {
                                dist = 0;
                            }
                        } else {
                            if (moves >= moveTicks) {
                                dist = lastDist;

                                if(moves == 1 && moveTicks == 1) {
                                    dist *= 0.53;
                                    dist -= 0.026;
                                } else {
                                    dist *= 0.91F;

                                    if(dist > 0.026F) {
                                        dist -= 0.026F * 0.98F;
                                    }
                                }
                            }
                        }

                        double motionX = -Math.sin(Math.toRadians(direction)) * dist;
                        double motionY = y - lastY;
                        double motionZ = Math.cos(Math.toRadians(direction)) * dist;

                        mc.thePlayer.moveEntityNoEvent(motionX, motionY, motionZ);

                        if (packet.getRotating()) {
                            PacketUtil.sendPacketFinal(new C03PacketPlayer.C06PacketPlayerPosLook(mc.thePlayer.posX, mc.thePlayer.posY, mc.thePlayer.posZ, packet.getYaw(), packet.getPitch(), packet.isOnGround()));
                        } else {
                            PacketUtil.sendPacketFinal(new C03PacketPlayer.C04PacketPlayerPosition(mc.thePlayer.posX, mc.thePlayer.posY, mc.thePlayer.posZ, packet.isOnGround()));
                        }

                        pastPositions.add(new Position(mc.thePlayer.posX, mc.thePlayer.posY, mc.thePlayer.posZ));

                        traveledDist += dist;

                        lastDist = dist;
                    } else {
                        lastDist = 0;
                    }

                    moves++;
                } else {
                    PacketUtil.sendPacketFinal(p);
                }
            }

            packetsQueue.clear();
        }
    }

    private int getMoveTicks() {
        if(!packetsQueue.isEmpty()) {
            double totalDist = Math.hypot(mc.thePlayer.posX - lastGroundX, mc.thePlayer.posZ - lastGroundZ);

            ArrayList<Position> positions = new ArrayList<>();

            for(Packet p : packetsQueue) {
                double x = lastGroundX, y = lastGroundY, z = lastGroundZ;

                if(p instanceof C03PacketPlayer) {
                    C03PacketPlayer packet = (C03PacketPlayer) p;

                    if(packet.isMoving()) {
                        x = packet.getX();
                        y = packet.getY();
                        z = packet.getZ();
                    }

                    positions.add(new Position(x, y, z));
                }
            }

            if(!positions.isEmpty()) {
                int stopForwardCount = positions.size();

                while(stopForwardCount > 0) {
                    double currentDist = 0;

                    double lastX = lastGroundX;
                    double lastZ = lastGroundZ;

                    int i = 0;

                    double lastDist = 0;

                    for(Position pos : positions) {
                        double x = pos.getX();
                        double z = pos.getZ();

                        double dist = Math.hypot(x - lastX, z - lastZ);

                        if(i >= stopForwardCount - 1) {
                            dist = lastDist;

                            dist *= 0.91F;

                            if(dist > 0.026F) {
                                dist -= 0.026F * 0.98F;
                            }
                        }

                        currentDist += dist;

                        lastX = x;
                        lastZ = z;

                        lastDist = dist;

                        i++;
                    }

                    if(currentDist <= totalDist) {
                        return stopForwardCount;
                    }

                    stopForwardCount--;
                }
            }
        }

        return 0;
    }

    @Listener
    public void onEntityAction(EntityActionEvent event) {
        if(noSprintSpoof.isEnabled()) {
            event.setSprinting(false);
        }
    }

    @Listener
    public void onRender3D(Render3DEvent event) {
        if(!renderMode.is("None") && mc.gameSettings.thirdPersonView > 0 && isBlinking()) {
            RenderUtil.prepareBoxRender(3.25F, 1F, 1F, 1F, 0.8F);

            RenderManager rm = mc.getRenderManager();
            float partialTicks = event.getPartialTicks();

            if(renderMode.is("Line")) {
                boolean first = true;

                double previousX = 0, previousY = 0, previousZ = 0;

                if(!pastPositions.isEmpty()) {
                    for(Position pos : pastPositions) {
                        Tessellator tessellator = Tessellator.getInstance();
                        WorldRenderer worldrenderer = tessellator.getWorldRenderer();

                        double renderX = pos.getX() - rm.renderPosX;
                        double renderY = pos.getY() - rm.renderPosY;
                        double renderZ = pos.getZ() - rm.renderPosZ;

                        worldrenderer.func_181668_a(3, DefaultVertexFormats.field_181705_e);

                        if(!first) {
                            worldrenderer.func_181662_b(previousX, previousY, previousZ).func_181675_d();
                            worldrenderer.func_181662_b(renderX, renderY, renderZ).func_181675_d();
                        }

                        tessellator.draw();

                        previousX = renderX;
                        previousY = renderY;
                        previousZ = renderZ;

                        first = false;
                    }
                }
            } else if(renderMode.is("Box")) {
                RenderUtil.renderCustomPlayerBox(rm, partialTicks, lastGroundX, lastGroundY, lastGroundZ);
            }

            RenderUtil.stopBoxRender();
        }
    }

    public boolean isBlinking() {
        return this.isEnabled() && !packetsQueue.isEmpty();
    }

    @Listener
    public int getPriority() {
        return 3;
    }

    private class Position {
        @Getter
        @Setter
        private final double x, y, z;

        private Position(double x, double y, double z) {
            this.x = x;
            this.y = y;
            this.z = z;
        }
    }

}
