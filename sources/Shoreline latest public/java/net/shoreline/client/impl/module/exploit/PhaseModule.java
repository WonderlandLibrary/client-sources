package net.shoreline.client.impl.module.exploit;

import net.minecraft.item.EnderPearlItem;
import net.minecraft.item.ItemStack;
import net.minecraft.item.Items;
import net.minecraft.network.packet.c2s.play.PlayerInteractItemC2SPacket;
import net.minecraft.network.packet.c2s.play.PlayerMoveC2SPacket;
import net.minecraft.util.Hand;
import net.minecraft.util.math.BlockPos;
import net.minecraft.util.math.Box;
import net.minecraft.util.math.MathHelper;
import net.minecraft.util.math.Vec3d;
import net.minecraft.util.shape.VoxelShapes;
import net.shoreline.client.api.config.Config;
import net.shoreline.client.api.config.setting.BooleanConfig;
import net.shoreline.client.api.config.setting.EnumConfig;
import net.shoreline.client.api.config.setting.NumberConfig;
import net.shoreline.client.api.event.EventStage;
import net.shoreline.client.api.event.listener.EventListener;
import net.shoreline.client.api.module.ModuleCategory;
import net.shoreline.client.api.module.RotationModule;
import net.shoreline.client.impl.event.network.PlayerUpdateEvent;
import net.shoreline.client.impl.event.network.PushOutOfBlocksEvent;
import net.shoreline.client.impl.event.world.BlockCollisionEvent;
import net.shoreline.client.init.Managers;
import net.shoreline.client.util.math.position.PositionUtil;
import net.shoreline.client.util.player.RotationUtil;
import net.shoreline.client.util.string.EnumFormatter;

/**
 * @author linus
 * @since 1.0
 */
public class PhaseModule extends RotationModule {
    //
    Config<PhaseMode> modeConfig = new EnumConfig<>("Mode", "The phase mode for clipping into blocks", PhaseMode.NORMAL, PhaseMode.values());
    Config<Integer> pitchConfig = new NumberConfig<>("Pitch", "The pitch to throw pearls", 70, 85, 90, () -> modeConfig.getValue() == PhaseMode.PEARL);
    Config<Float> blocksConfig = new NumberConfig<>("Blocks", "The blocks distance to phase clip", 0.001f, 0.003f, 10.0f, () -> modeConfig.getValue() != PhaseMode.PEARL);
    Config<Float> distanceConfig = new NumberConfig<>("Distance", "The distance to phase", 0.0f, 0.2f, 10.0f, () -> modeConfig.getValue() != PhaseMode.PEARL);
    Config<Boolean> autoClipConfig = new BooleanConfig("AutoClip", "Automatically clips into the block", true);

    /**
     *
     */
    public PhaseModule() {
        super("Phase", "Allows player to phase through solid blocks", ModuleCategory.EXPLOITS, 1000);
    }

    @Override
    public String getModuleData() {
        return EnumFormatter.formatEnum(modeConfig.getValue());
    }

    @Override
    public void onEnable() {
        if (mc.player == null) {
            return;
        }
        if (modeConfig.getValue() == PhaseMode.PEARL) {
            int pearlSlot = -1;
            for (int i = 0; i < 9; i++) {
                ItemStack stack = mc.player.getInventory().getStack(i);
                if (stack.getItem() instanceof EnderPearlItem) {
                    pearlSlot = i;
                    break;
                }
            }
            if (pearlSlot == -1 || mc.player.getItemCooldownManager().isCoolingDown(Items.ENDER_PEARL)) {
                disable();
                return;
            }
            float prevYaw = mc.player.getYaw();
            float prevPitch = mc.player.getPitch();
            float[] rotations = RotationUtil.getRotationsTo(mc.player.getEyePos(),
                    new Vec3d(Math.floor(mc.player.getX()) + 0.5, 0.0, Math.floor(mc.player.getZ()) + 0.5));
            setRotationClient(rotations[0] + 180.0f, pitchConfig.getValue());
            // mc.player.networkHandler.sendPacket(new PlayerMoveC2SPacket.LookAndOnGround(rotations[0] + 180.0f, pitchConfig.getValue(), mc.player.isOnGround()));
            Managers.INVENTORY.setSlot(pearlSlot);
            Managers.NETWORK.sendPacket(new PlayerMoveC2SPacket.Full(mc.player.getX(), mc.player.getY(), mc.player.getZ(), rotations[0] + 180.0f, pitchConfig.getValue(), mc.player.isOnGround()));
            Managers.NETWORK.sendSequencedPacket(id -> new PlayerInteractItemC2SPacket(Hand.MAIN_HAND, id));
            mc.player.swingHand(Hand.MAIN_HAND);
            Managers.INVENTORY.syncToClient();
            setRotationClient(prevYaw, prevPitch);
            disable();
        } else if (autoClipConfig.getValue()) {
            double cos = Math.cos(Math.toRadians(mc.player.getYaw() + 90.0f));
            double sin = Math.sin(Math.toRadians(mc.player.getYaw() + 90.0f));
            mc.player.setPosition(mc.player.getX() + (1.0 * blocksConfig.getValue() * cos + 0.0 * blocksConfig.getValue() * sin),
                    mc.player.getY(), mc.player.getZ() + (1.0 * blocksConfig.getValue() * sin - 0.0 * blocksConfig.getValue() * cos));
        }
    }

    @EventListener
    public void onBlockCollision(BlockCollisionEvent event) {
        if (mc.player == null) {
            return;
        }
        switch (modeConfig.getValue()) {
            case NORMAL -> {
                if (event.getVoxelShape() != VoxelShapes.empty() && event.getVoxelShape().getBoundingBox().maxY > mc.player.getBoundingBox().minY && mc.player.isSneaking()) {
                    event.cancel();
                    event.setVoxelShape(VoxelShapes.empty());
                }
            }
            case SAND -> {
                event.cancel();
                event.setVoxelShape(VoxelShapes.empty());
                mc.player.noClip = true;
            }
            case CLIMB -> {
                if (mc.player.horizontalCollision) {
                    event.cancel();
                    event.setVoxelShape(VoxelShapes.empty());
                }
                if (mc.player.input.sneaking || (mc.player.input.jumping
                        && event.getPos().getY() > mc.player.getY())) {
                    event.cancel();
                }
            }
        }
    }

    @EventListener
    public void onPlayerUpdate(PlayerUpdateEvent event) {
        if (event.getStage() != EventStage.PRE) {
            return;
        }
        switch (modeConfig.getValue()) {
            case NORMAL -> {
                if (mc.player.isSneaking() && isPhasing()) {
                    float yaw = mc.player.getYaw();
                    mc.player.setBoundingBox(mc.player.getBoundingBox().offset(
                            distanceConfig.getValue() * Math.cos(Math.toRadians(yaw + 90.0f)),
                            0.0, distanceConfig.getValue() * Math.sin(Math.toRadians(yaw + 90.0f))));
                }
            }
            case SAND -> {
                Managers.MOVEMENT.setMotionY(0.0);
                if (mc.isWindowFocused()) {
                    if (mc.player.input.jumping) {
                        Managers.MOVEMENT.setMotionY(mc.player.getVelocity().y + 0.3);
                    }
                    if (mc.player.input.sneaking) {
                        Managers.MOVEMENT.setMotionY(mc.player.getVelocity().y - 0.3);
                    }
                }
                mc.player.noClip = true;
            }
        }
    }

    @EventListener
    public void onPushOutOfBlocks(PushOutOfBlocksEvent event) {
        event.cancel();
    }

    public boolean isPhasing() {
        Box bb = mc.player.getBoundingBox();
        for (int x = MathHelper.floor(bb.minX); x < MathHelper.floor(bb.maxX) + 1; x++) {
            for (int y = MathHelper.floor(bb.minY); y < MathHelper.floor(bb.maxY) + 1; y++) {
                for (int z = MathHelper.floor(bb.minZ); z < MathHelper.floor(bb.maxZ) + 1; z++) {
                    if (mc.world.getBlockState(new BlockPos(x, y, z)).blocksMovement()) {
                        if (bb.intersects(new Box(x, y, z, x + 1.0, y + 1.0, z + 1.0))) {
                            return true;
                        }
                    }
                }
            }
        }
        return false;
    }

    public enum PhaseMode {
        NORMAL,
        SAND,
        CLIMB,
        PEARL
    }
}
