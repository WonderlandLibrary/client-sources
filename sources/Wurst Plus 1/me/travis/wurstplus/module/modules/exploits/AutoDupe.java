// package me.travis.wurstplus.module.modules.exploits;

// import java.awt.*;
// import java.awt.event.*;

// import me.travis.wurstplus.command.Command;
// import me.travis.wurstplus.module.Module;
// import me.travis.wurstplus.setting.Setting;
// import me.travis.wurstplus.setting.Settings;
// import net.minecraft.network.play.server.SPacketChunkData;
// import me.zero.alpine.listener.Listener;
// import me.zero.alpine.listener.EventHandler;
// import me.travis.wurstplus.event.events.PacketEvent;
// import me.travis.wurstplus.util.WorldUtils;

// import net.minecraft.entity.passive.EntityDonkey;
// import net.minecraft.entity.Entity;
// import net.minecraft.util.EnumFacing;
// import net.minecraft.util.math.BlockPos;
// import net.minecraftforge.client.event.InputUpdateEvent;
// import net.minecraftforge.fml.common.ObfuscationReflectionHelper;
// import net.minecraft.item.ItemStack;
// import net.minecraft.inventory.ClickType;
// import net.minecraft.entity.player.EntityPlayer;
// import net.minecraft.entity.passive.*;
// import net.minecraft.util.NonNullList;
// import net.minecraft.inventory.ContainerHorseChest;
// import net.minecraft.inventory.InventoryBasic;


// @Module.Info(name="Auto Dupe", category=Module.Category.EXPLOITS)
// public class AutoDupe extends Module {
    
//     private Setting<Boolean> debug = this.register(Settings.b("Debug Mode", false));
//     private Setting<Boolean> loop = this.register(Settings.b("Loop Mode", false));
//     private Setting<Integer> wait = this.register(Settings.integerBuilder("Hopper Wait").withMinimum(1).withValue(10).withMaximum(10000).build());

//     private int length;
//     private int delay;

//     private float yaw;

//     private double initX;
//     private double initZ;
//     private double goalX;
//     private double goalZ;
//     private double lastX;
//     private double lastZ;

//     private boolean atEnd;
//     private boolean packetSent;
//     private boolean shouldMove;
//     private boolean firstRun;
//     private boolean runComp;
//     private boolean initMove;

//     public BlockPos finalPos;
//     public EntityDonkey donkey;
//     public EnumFacing face;
//     public Robot r;
//     public KeyEvent k;

//     @Override
//     protected void onEnable() {
//         if (mc.world == null) {
//             this.disable();
//             return;
//         }

//         this.initMove = true;
//         this.runComp = false;
//         this.firstRun = true;
//         this.atEnd = false;
//         this.length = 8;
//         this.delay = 0;
//         this.shouldMove = false;

//         getFace();
//         this.goalX = getGoalX();
//         this.goalZ = getGoalZ();
//         clampYaw();
//         this.yaw = mc.player.rotationYaw;
//         this.initX = mc.player.posX;
//         this.initZ = mc.player.posZ;

//         finalPos = new BlockPos(this.goalX, mc.player.posY, this.goalZ);
        
//         try {
//             r = new Robot();
//         } catch (Exception e) {
//             Command.sendChatMessage("Restart please");
//             this.disable();
//         }

//         getCoords();
//     }

//     @EventHandler
//     private Listener<PacketEvent.Receive> packetEventReceiveListener = new Listener<PacketEvent.Receive>(event -> {
//         if (this.isDisabled() || mc.player == null) {
//             return;
//         }
//         if (event.getPacket() instanceof SPacketChunkData) {
//             if (this.atEnd) {
//                 this.packetSent = true;
//             }
//         }
//     });

//     @EventHandler
//     private Listener<InputUpdateEvent> inputUpdateEventListener = new Listener<>(event -> {
//         if (this.shouldMove) {
//             event.getMovementInput().moveForward = 1;
//         }
//     });

//     public void getCoords() {
//         if (this.debug.getValue()) {
//             Command.sendChatMessage("End x: " + this.goalX + " End z: "+this.goalZ);
//             Command.sendChatMessage("Facing: " + face.getName());
//             Command.sendChatMessage("Yaw: " + mc.player.rotationYaw);
//         }
//     }

//     @Override
//     public void onUpdate() {
//         if (mc.player == null || this.isDisabled()) {
//             return;
//         }
//         if (!mc.playerController.isRidingHorse() && this.initMove == true) {
//             getDonkey();
//             getOnDokey();
//             return;
//         }
//         if (mc.playerController.isRidingHorse()) {
//             if (this.initMove) {
//                 runStartCommands();
//                 this.shouldMove = true;
//                 this.initMove = false;
//             }
//         }
//         if (this.runComp) {
//             if (this.delay > this.wait.getValue()) {
//                 Command.sendChatMessage("done");
//                 r.keyPress(KeyEvent.VK_U);
//                 r.keyRelease(KeyEvent.VK_U);
//                 // throwItems();
//                 this.disable();
//                 if (this.loop.getValue()) {
//                     getOnDokey();
//                     r.keyPress(KeyEvent.VK_SHIFT);
//                     r.keyRelease(KeyEvent.VK_SHIFT);
//                 }
//                 return;
//             }
            
//         } else {
//             mc.player.rotationYaw = this.yaw;
//             if (this.atEnd) {
//                 Command.sendChatMessage("at end");
//                 if (this.firstRun) {
//                     Command.sendChatMessage("is first run");
//                     if (this.packetSent || this.delay > 250) {
//                         Command.sendChatMessage("packet sent");
//                         // reloadChunks();
//                         this.firstRun = false;
//                         this.atEnd = false;
//                         this.packetSent = false;
//                         this.yaw += 180;
//                         mc.player.rotationYaw = this.yaw;
//                         this.goalX = this.initX;
//                         this.goalZ = this.initZ;
//                         this.initX = mc.player.posX;
//                         this.initZ = mc.player.posZ;
//                         face = getFace();
//                         getCoords();
//                         this.shouldMove = true;
//                         return;
//                     } 
//                     this.delay++;
//                 } else {
//                     this.shouldMove = false;
//                     runEndCommands();
//                     return;
//                 }
//             }
//             isPastCoords();
//         }
//     }

//     public void clampYaw() {
//         if (face == EnumFacing.NORTH) {
//             mc.player.rotationYaw = 180;
//         }
//         else if (face == EnumFacing.SOUTH) {
//             mc.player.rotationYaw = 0;
//         }
//         else if (face == EnumFacing.WEST) {
//             mc.player.rotationYaw = 90;
//         }
//         else {
//             mc.player.rotationYaw = -90;
//         }
//     }

//     public double getGoalX() {
//         if (face == EnumFacing.SOUTH || face == EnumFacing.NORTH) {
//             return mc.player.posX;
//         } else if (face == EnumFacing.EAST) {
//             return mc.player.posX + this.length*16;
//         } else if (face == EnumFacing.WEST) {
//             return mc.player.posX - this.length*16;
//         } else {
//             return mc.player.posX;
//         }
//     }

//     public double getGoalZ() {
//         if (face == EnumFacing.EAST || face == EnumFacing.WEST) {
//             return mc.player.posZ;
//         } else if (face == EnumFacing.SOUTH) {
//             return mc.player.posZ + this.length*16;
//         } else if (face == EnumFacing.NORTH) {
//             return mc.player.posZ - this.length*16;
//         } else {
//             return mc.player.posZ;
//         }
//     }

//     public EnumFacing getFace() {
//         boolean isNegative = false;
//         this.yaw = mc.player.rotationYaw;
//         if (this.yaw < 0) { // if yaw is negative flip the x
//             isNegative = true;
//         }
//         int dir = (int) Math.round(Math.abs(this.yaw)) % 360; // yet the magnatude of the player's direction

//         if (135 < dir && dir < 225) { // if looking south
//             face = EnumFacing.NORTH;
//         } else if (225 < dir && dir < 315) { // if looking west
//             if (isNegative) {
//                 face = EnumFacing.WEST;
//             } else {
//                 face = EnumFacing.EAST;
//             }            
//         } else if (45 < dir && dir < 135) { // if looking east
//             if (isNegative) {
//                 face = EnumFacing.EAST;
//             } else {
//                 face = EnumFacing.WEST;
//             }  
//         } else { // if looking north
//             face = EnumFacing.SOUTH;
//         }
//         return face;
//     }

//     public void isPastCoords() {
//         if (face == EnumFacing.NORTH) {
//             if (this.initZ < this.goalZ) {
//                 if (!this.atEnd && Math.round(mc.player.posZ) >= this.goalZ) {
//                     this.atEnd = true;
//                     this.shouldMove = false;
//                 }
//             }
//             if (this.initZ > this.goalZ) {
//                 if (!this.atEnd && Math.round(mc.player.posZ) <= this.goalZ) {
//                     this.atEnd = true;
//                     this.shouldMove = false;                    
//                 }
//             }
//         } else if (face == EnumFacing.EAST) {
//             if (this.initX < this.goalX) {
//                 if (!this.atEnd && Math.round(mc.player.posX) >= this.goalX) {
//                     this.atEnd = true;
//                     this.shouldMove = false;                    
//                 }
//             }
//             if (this.initX > this.goalX) {
//                 if (!this.atEnd && Math.round(mc.player.posX) <= this.goalX) {
//                     this.atEnd = true;
//                     this.shouldMove = false;                    
//                 }
//             }
//         } else if (face == EnumFacing.WEST) {
//             if (this.initX < this.goalX) {
//                 if (!this.atEnd && Math.round(mc.player.posX) >= this.goalX) {
//                     this.atEnd = true;
//                     this.shouldMove = false;                    
//                 }
//             }
//             if (this.initX > this.goalX) {
//                 if (!this.atEnd && Math.round(mc.player.posX) <= this.goalX) {
//                     this.atEnd = true;
//                     this.shouldMove = false;                   
//                 }
//             }
//         } else if (face == EnumFacing.SOUTH) {
//             if (this.initZ < this.goalZ) {
//                 if (!this.atEnd && Math.round(mc.player.posZ) >= this.goalZ) {
//                     this.atEnd = true;
//                     this.shouldMove = false;                    
//                 }
//             }
//             if (this.initZ > this.goalZ) {
//                 if (!this.atEnd && Math.round(mc.player.posZ) <= this.goalZ) {
//                     this.atEnd = true;
//                     this.shouldMove = false;                    
//                 }
//             }
//         }
//     }

//     public void throwItems() {
//         final Entity ridingEntity = mc.player.getRidingEntity();
//         if (ridingEntity != null && ridingEntity instanceof AbstractHorse) {
//             final AbstractHorse horse = (AbstractHorse)ridingEntity;
//             final ContainerHorseChest horseChest = (ContainerHorseChest)ObfuscationReflectionHelper.getPrivateValue((Class)AbstractHorse.class, (Object)horse, new String[] { "horseChest", "field_110296_bG" });
//             final NonNullList<ItemStack> horseItems = (NonNullList<ItemStack>)ObfuscationReflectionHelper.getPrivateValue((Class)InventoryBasic.class, (Object)horseChest, new String[] { "inventoryContents", "field_70482_c"});
//             System.out.println(horseItems.toString());
//             for (int i = 0; i < mc.player.inventory.getSizeInventory(); ++i) {
//                 System.out.println("Dropping item in slot: " + i);
//                 mc.playerController.windowClick(mc.player.openContainer.windowId, i, 0, ClickType.THROW, (EntityPlayer)mc.player);
//             }
//         }
//         this.setEnabled(false);
//     }

//     public void takeDonkeyItems() {
//         r.keyPress(KeyEvent.VK_E);
//         r.keyRelease(KeyEvent.VK_E);
//         this.runComp = true;
//     }

//     public void getOnDokey() {
//         BlockPos pos = new BlockPos(donkey.posX+0.5, donkey.posY-1, donkey.posZ+0.5);
//         WorldUtils.lookAtBlock(pos);
//         r.mousePress(InputEvent.BUTTON3_DOWN_MASK);
//         r.mouseRelease(InputEvent.BUTTON3_DOWN_MASK);
//     }

//     public void runStartCommands() {
//         mc.player.sendChatMessage(".vanish dismount");
//         r.keyPress(KeyEvent.VK_U);
//         r.keyRelease(KeyEvent.VK_U);
//     }

//     public void runEndCommands() {
//         mc.player.sendChatMessage(".vanish remount");
//         takeDonkeyItems();
//     }
 
//     public void reloadChunks() {
//         r.keyPress(KeyEvent.VK_F3);
//         r.keyPress(KeyEvent.VK_A);
//         r.keyRelease(KeyEvent.VK_A);
//         r.keyRelease(KeyEvent.VK_F3);
//     }

//     public boolean getDonkey() {
//         for (Entity ent : mc.world.loadedEntityList) {
//             if (ent instanceof EntityDonkey) {
//                 donkey = (EntityDonkey) ent;
//                 return true;
//             }
//         }
//         return false;
//     }
// }