package kevin.module.modules.exploit;

import kevin.event.*;
import kevin.main.KevinClient;
import kevin.module.*;
import kevin.module.modules.combat.BackTrack;
import kevin.utils.RenderUtils;
import net.minecraft.client.renderer.entity.RenderManager;
import net.minecraft.entity.Entity;
import net.minecraft.entity.item.EntityArmorStand;
import net.minecraft.network.Packet;
import net.minecraft.network.play.INetHandlerPlayClient;
import net.minecraft.network.play.client.C08PacketPlayerBlockPlacement;
import net.minecraft.network.play.server.*;
import net.minecraft.util.AxisAlignedBB;
import org.lwjgl.input.Keyboard;

import java.util.LinkedHashMap;
import java.util.LinkedList;

import static org.lwjgl.opengl.GL11.*;

@SuppressWarnings("unchecked")
public class ServerSidePacketDelayer extends Module {
    private final ListValue mode = new ListValue("Mode", new String[]{"Size", "SmartGrimACGhostBlock", "Time"}, "Size");
    private final TextValue ignored = new TextValue("Time mode is inactive now!", "");
    private final IntegerValue size = new IntegerValue("MaxDelaySize", 500, 0, 1200);
    private final IntegerValue time = new IntegerValue("MaxDelayTime", 1000, 0, 6000);

    private final LinkedList<PacketEvent> packets = new LinkedList<>();
    private final LinkedHashMap<Integer, PosData> entityPosMap = new LinkedHashMap<>();
    private boolean backTrackEnabled = false;
    private BackTrack backTrack = null;
    private boolean hasPlace = false;
    public ServerSidePacketDelayer() {
        super("ServerSidePacketDelayer", "Delay all server-side packets", Keyboard.KEY_NONE, ModuleCategory.EXPLOIT);
    }

    @Override
    public void onEnable() {
        if (backTrack == null) backTrack = KevinClient.moduleManager.getModule(BackTrack.class);
        if (backTrack.getState()) {
            backTrackEnabled = true;
            backTrack.setState(false);
        }
    }

    @EventTarget
    public final void onWorld(WorldEvent event) {
        clear();
    }

    @EventTarget
    public final void onPacket(PacketEvent event) {
        if (event.isCancelled()) return;
        final Packet<?> packet = event.getPacket();
        if (packet instanceof S03PacketTimeUpdate) return;
        if (packet instanceof S01PacketJoinGame || packet instanceof S07PacketRespawn) {
            clear();
            return;
        }
        if (packet.getClass().getName().startsWith("net.minecraft.network.play.server.")) {
            packets.add(event);
            event.cancelEvent();
            if (packet instanceof S0CPacketSpawnPlayer) {
                final S0CPacketSpawnPlayer spawn = (S0CPacketSpawnPlayer) packet;
                if (entityPosMap.containsKey(spawn.getEntityID())) return;
                final PosData pd = new PosData();
                pd.prevX = (pd.x = spawn.getX()) / 32.0;
                pd.prevY = (pd.y = spawn.getY()) / 32.0;
                pd.prevZ = (pd.z = spawn.getZ()) / 32.0;
                pd.destroy = true;
                entityPosMap.put(spawn.getEntityID(), pd);
            } else if (packet instanceof S13PacketDestroyEntities) {
                for (int entityID : ((S13PacketDestroyEntities) packet).getEntityIDs()) {
                    final PosData pd = entityPosMap.get(entityID);
                    if (pd != null) pd.destroy = true;
                }
            } else if (packet instanceof S14PacketEntity) {
                final S14PacketEntity pEntity = (S14PacketEntity) packet;
                final PosData pd;
                if (!entityPosMap.containsKey(pEntity.getEntityId())) {
                    final Entity entity = pEntity.getEntity(mc.theWorld);
                    if (entity == null || entity instanceof EntityArmorStand) return;
                    pd = new PosData();
                    pd.x = entity.serverPosX;
                    pd.y = entity.serverPosY;
                    pd.z = entity.serverPosZ;
                    final float adder = entity.getCollisionBorderSize();
                    pd.width = entity.width / 2 + adder;
                    pd.height = entity.height + adder;
                    entityPosMap.put(pEntity.getEntityId(), pd);
                } else pd = entityPosMap.get(pEntity.getEntityId());
                pd.motionX(pEntity.func_149062_c());
                pd.motionY(pEntity.func_149061_d());
                pd.motionZ(pEntity.func_149064_e());
            } else if (packet instanceof S18PacketEntityTeleport) {
                final S18PacketEntityTeleport tp = (S18PacketEntityTeleport) packet;
                final PosData pd;
                if (!entityPosMap.containsKey(tp.getEntityId())) {
                    pd = new PosData();
                    final Entity entity;
                    if ((entity = mc.theWorld.getEntityByID(tp.getEntityId())) != null) {
                        final float adder = entity.getCollisionBorderSize();
                        pd.width = entity.width / 2 + adder;
                        pd.height = entity.height + adder;
                    }
                    entityPosMap.put(tp.getEntityId(), pd);
                } else pd = entityPosMap.get(tp.getEntityId());
                pd.x = tp.getX();
                pd.y = tp.getY();
                pd.z = tp.getZ();
            }
        } else if (packet instanceof C08PacketPlayerBlockPlacement) {
            C08PacketPlayerBlockPlacement place = (C08PacketPlayerBlockPlacement) packet;
            if (place.getPlacedBlockDirection() == 255) return;
            hasPlace = true;
        }
    }

    @EventTarget
    public final void onPost(MotionEvent event) {
        if (event.getEventState() == EventState.PRE) return;
        if (packets.isEmpty()) return;
        if (mode.equal("Size") && packets.size() > size.get()) clear(this.size.get());
        else if (mode.equal("SmartGrimACGhostBlock") && hasPlace) {
            clear();
            hasPlace = false;
        }
    }

    @EventTarget
    public final void onUpdate(UpdateEvent event) {
        if (entityPosMap.isEmpty()) return;
        for (final PosData value : entityPosMap.values()) {
            value.update();
        }
    }

    @Override
    public void onDisable() {
        hasPlace = false;
        clear();
        if (backTrack != null && backTrackEnabled) backTrack.setState(true);
    }

    private void clear(int size) {
        if (packets.isEmpty()) return;
        final INetHandlerPlayClient handler = mc.getNetHandler();
        while (packets.size() > size) {
            final PacketEvent event = packets.pollFirst();
            if (event == null) continue;
            try {
                final Packet<INetHandlerPlayClient> packet = (Packet<INetHandlerPlayClient>) event.getPacket();
                packet.processPacket(handler);
            } catch (Exception ignored) {}
        }
    }

    @EventTarget
    public final void onRender(Render3DEvent event) {
        // TODO: draw with partialTicks
        if (entityPosMap.isEmpty()) return;
        final RenderManager manager = mc.getRenderManager();
        final double renderPosX = manager.getRenderPosX(), renderPosY = manager.getRenderPosY(), renderPosZ = manager.getRenderPosZ();

        glPushMatrix();
        glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
        glEnable(GL_BLEND);
        glDisable(GL_TEXTURE_2D);
        glDisable(GL_DEPTH_TEST);
        glDepthMask(false);

        for (final PosData data : entityPosMap.values()) {
            final double px = data.getPosX() - renderPosX, py = data.getPosY() - renderPosY, pz = data.getPosZ() - renderPosZ;
            final AxisAlignedBB bb = new AxisAlignedBB(px - data.width, py, pz - data.width, px + data.width, py + data.height, pz + data.width);
            if (data.destroy) RenderUtils.glColor(250, 25, 20, 150);
            else RenderUtils.glColor(238, 238, 238, 160);
            RenderUtils.drawFilledBox(bb);
        }

        glColor4f(1.0f, 1.0f, 1.0f, 1.0f);
        glDepthMask(true);
        glDisable(GL_BLEND);
        glEnable(GL_TEXTURE_2D);
        glEnable(GL_DEPTH_TEST);
        glPopMatrix();
    }

    private void clear() {
        clear(0);
        entityPosMap.clear();
    }

    private static class PosData {
        public float height = 1.9f, width = 0.4f;
        public boolean destroy = false;
        public int x = 0, y = 0, z = 0;
        public double prevX = 0, prevY = 0, prevZ = 0;
        private int increment = 0;

        public double getPosX() {
            return x / 32.0;
        }

        public double getPosY() {
            return y / 32.0;
        }

        public double getPosZ() {
            return z / 32.0;
        }

        public void motionX(int x) {
            prevX = getPosX();
            this.x += x;
            increment = 3;
        }

        public void motionY(int y) {
            prevY = getPosY();
            this.y += y;
            increment = 3;
        }

        public void motionZ(int z) {
            prevZ = getPosZ();
            this.z += z;
            increment = 3;
        }

        public void update() {
            if (increment > 0) {
                prevX += ((x / 32.0) - prevX) / increment;
                prevY += ((y / 32.0) - prevY) / increment;
                prevZ += ((z / 32.0) - prevZ) / increment;
                --increment;
            }
        }
    }
}
