package lunadevs.luna.module.exploits;

import org.lwjgl.input.Keyboard;

import com.darkmagician6.eventapi.EventTarget;

import lunadevs.luna.category.Category;
import lunadevs.luna.events.BoundingBoxEvent;
import lunadevs.luna.events.Event;
import lunadevs.luna.events.InsideBlockRenderEvent;
import lunadevs.luna.events.PushOutOfBlocksEvent;
import lunadevs.luna.events.UpdateEvent;
import lunadevs.luna.main.Luna;
import lunadevs.luna.module.Module;
import lunadevs.luna.utils.ClientUtils;
import net.minecraft.block.Block;
import net.minecraft.block.BlockAir;
import net.minecraft.block.BlockHopper;
import net.minecraft.client.Minecraft;
import net.minecraft.network.play.client.C03PacketPlayer;
import net.minecraft.util.AxisAlignedBB;
import net.minecraft.util.BlockPos;
import net.minecraft.util.MathHelper;

public class FastPhase extends Module{

	public FastPhase() {
		super("FastPhase", Keyboard.KEY_NONE, Category.EXPLOITS, false);
	}
	 @Override
	  public void onUpdate()
	  {
		 if(!this.isEnabled)
			 return;
	      if ((ClientUtils.player().isCollidedHorizontally) && (!ClientUtils.player().isOnLadder() && mc.thePlayer.isSneaking()))
	      {
	        double xOff = 0.0D;
	        double zOff = 0.0D;
	        double multiplier = 1.1D;
	        double mx = Math.cos(Math.toRadians(ClientUtils.yaw() + 90.0F));
	        double mz = Math.sin(Math.toRadians(ClientUtils.yaw() + 90.0F));
	        xOff = ClientUtils.movementInput().moveForward * multiplier * mx + ClientUtils.movementInput().moveStrafe * multiplier * mz;
	        zOff = ClientUtils.movementInput().moveForward * multiplier * mz - ClientUtils.movementInput().moveStrafe * multiplier * mx;
	        ClientUtils.packet(new C03PacketPlayer.C04PacketPlayerPosition(ClientUtils.x() + xOff, ClientUtils.y(), ClientUtils.z() + zOff, false));
	        for (int i = 1; i < 10; i++) {
	          ClientUtils.packet(new C03PacketPlayer.C04PacketPlayerPosition(ClientUtils.x(), 8.988465674311579E307D, ClientUtils.z(), false));
	        }
	        ClientUtils.player().setPosition(ClientUtils.x() + xOff, ClientUtils.y(), ClientUtils.z() + zOff);
	        return;
	    }
	  }
	 
	 @EventTarget
	  public void onBB(BoundingBoxEvent event)
	  {
	    if ((isInsideBlock()) && (event.getBoundingBox() != null) && (event.getBoundingBox().maxY > ClientUtils.player().boundingBox.minY)) {
	      event.setBoundingBox(null);
	    }
	  }
	  
	  @EventTarget
	  public void onPush(PushOutOfBlocksEvent event)
	  {
	    event.setCancelled(true);
	  }
	  
	  @EventTarget
	  private void onInsideBlockRender(InsideBlockRenderEvent event)
	  {
	    event.setCancelled(true);
	  }
	  
	  private boolean isInsideBlock()
	  {
	    for (int x = MathHelper.floor_double(ClientUtils.player().boundingBox.minX); x < MathHelper.floor_double(ClientUtils.player().boundingBox.maxX) + 1; x++) {
	      for (int y = MathHelper.floor_double(ClientUtils.player().boundingBox.minY); y < MathHelper.floor_double(ClientUtils.player().boundingBox.maxY) + 1; y++) {
	        for (int z = MathHelper.floor_double(ClientUtils.player().boundingBox.minZ); z < MathHelper.floor_double(ClientUtils.player().boundingBox.maxZ) + 1; z++)
	        {
	          Block block = ClientUtils.world().getBlockState(new BlockPos(x, y, z)).getBlock();
	          if ((block != null) && (!(block instanceof BlockAir)))
	          {
	            AxisAlignedBB boundingBox = block.getCollisionBoundingBox(ClientUtils.world(), new BlockPos(x, y, z), ClientUtils.world().getBlockState(new BlockPos(x, y, z)));
	            if ((block instanceof BlockHopper)) {
	              boundingBox = new AxisAlignedBB(x, y, z, x + 1, y + 1, z + 1);
	            }
	            if (boundingBox != null) {
	              if (ClientUtils.player().boundingBox.intersectsWith(boundingBox)) {
	                return true;
	              }
	            }
	          }
	        }
	      }
	    }
	    return false;
	  }
	
	@Override
	public void onEnable() {
	}
	@Override
	public void onDisable() {
		super.onDisable();
	}
	
	@Override
	public String getValue() {
		return null;
	}

}
