package net.ccbluex.liquidbounce.features.module.modules.exploit;

import net.ccbluex.liquidbounce.api.minecraft.client.network.IINetHandlerPlayClient;
import net.ccbluex.liquidbounce.api.minecraft.network.IPacket;
import net.ccbluex.liquidbounce.api.minecraft.network.play.client.ICPacketPlayer;
import net.ccbluex.liquidbounce.api.minecraft.util.IAxisAlignedBB;
import net.ccbluex.liquidbounce.api.minecraft.util.WBlockPos;
import net.ccbluex.liquidbounce.event.BlockBBEvent;
import net.ccbluex.liquidbounce.event.EventTarget;
import net.ccbluex.liquidbounce.event.MoveEvent;
import net.ccbluex.liquidbounce.event.PacketEvent;
import net.ccbluex.liquidbounce.event.PushOutEvent;
import net.ccbluex.liquidbounce.event.UpdateEvent;
import net.ccbluex.liquidbounce.features.module.Module;
import net.ccbluex.liquidbounce.features.module.ModuleCategory;
import net.ccbluex.liquidbounce.features.module.ModuleInfo;
import net.ccbluex.liquidbounce.utils.MovementUtils;
import net.ccbluex.liquidbounce.utils.block.BlockUtils;
import net.ccbluex.liquidbounce.utils.timer.TickTimer;
import net.ccbluex.liquidbounce.value.ListValue;

@ModuleInfo(name="Phase", description="Allows you to walk through blocks.", category=ModuleCategory.EXPLOIT)
public class Phase
extends Module {
    private final ListValue modeValue = new ListValue("Mode", new String[]{"Vanilla", "Skip", "Spartan", "Clip", "AAC3.5.0", "Mineplex"}, "Vanilla");
    private final TickTimer tickTimer = new TickTimer();
    private boolean mineplexClip;
    private final TickTimer mineplexTickTimer = new TickTimer();

    @EventTarget
    public void onUpdate(UpdateEvent event) {
        boolean isInsideBlock = BlockUtils.collideBlockIntersects(mc.getThePlayer().getEntityBoundingBox(), block -> !classProvider.isBlockAir(block));
        if (isInsideBlock && !((String)this.modeValue.get()).equalsIgnoreCase("Mineplex")) {
            mc.getThePlayer().setNoClip(true);
            mc.getThePlayer().setMotionY(0.0);
            mc.getThePlayer().setOnGround(false);
        }
        IINetHandlerPlayClient netHandlerPlayClient = mc.getNetHandler();
        switch (((String)this.modeValue.get()).toLowerCase()) {
            case "vanilla": {
                if (!mc.getThePlayer().getOnGround() || !this.tickTimer.hasTimePassed(2) || !mc.getThePlayer().isCollidedHorizontally() || isInsideBlock && !mc.getThePlayer().isSneaking()) break;
                netHandlerPlayClient.addToSendQueue(classProvider.createCPacketPlayerPosition(mc.getThePlayer().getPosX(), mc.getThePlayer().getPosY(), mc.getThePlayer().getPosZ(), true));
                netHandlerPlayClient.addToSendQueue(classProvider.createCPacketPlayerPosition(0.5, 0.0, 0.5, true));
                netHandlerPlayClient.addToSendQueue(classProvider.createCPacketPlayerPosition(mc.getThePlayer().getPosX(), mc.getThePlayer().getPosY(), mc.getThePlayer().getPosZ(), true));
                netHandlerPlayClient.addToSendQueue(classProvider.createCPacketPlayerPosition(mc.getThePlayer().getPosX(), mc.getThePlayer().getPosY() + 0.2, mc.getThePlayer().getPosZ(), true));
                netHandlerPlayClient.addToSendQueue(classProvider.createCPacketPlayerPosition(0.5, 0.0, 0.5, true));
                netHandlerPlayClient.addToSendQueue(classProvider.createCPacketPlayerPosition(mc.getThePlayer().getPosX() + 0.5, mc.getThePlayer().getPosY(), mc.getThePlayer().getPosZ() + 0.5, true));
                double yaw = Math.toRadians(mc.getThePlayer().getRotationYaw());
                double x = -Math.sin(yaw) * 0.04;
                double z = Math.cos(yaw) * 0.04;
                mc.getThePlayer().setPosition(mc.getThePlayer().getPosX() + x, mc.getThePlayer().getPosY(), mc.getThePlayer().getPosZ() + z);
                this.tickTimer.reset();
                break;
            }
            case "skip": {
                if (!mc.getThePlayer().getOnGround() || !this.tickTimer.hasTimePassed(2) || !mc.getThePlayer().isCollidedHorizontally() || isInsideBlock && !mc.getThePlayer().isSneaking()) break;
                double direction = MovementUtils.getDirection();
                double posX = -Math.sin(direction) * 0.3;
                double posZ = Math.cos(direction) * 0.3;
                for (int i = 0; i < 3; ++i) {
                    mc.getNetHandler().addToSendQueue(classProvider.createCPacketPlayerPosition(mc.getThePlayer().getPosX(), mc.getThePlayer().getPosY() + 0.06, mc.getThePlayer().getPosZ(), true));
                    mc.getNetHandler().addToSendQueue(classProvider.createCPacketPlayerPosition(mc.getThePlayer().getPosX() + posX * (double)i, mc.getThePlayer().getPosY(), mc.getThePlayer().getPosZ() + posZ * (double)i, true));
                }
                mc.getThePlayer().setEntityBoundingBox(mc.getThePlayer().getEntityBoundingBox().offset(posX, 0.0, posZ));
                mc.getThePlayer().setPositionAndUpdate(mc.getThePlayer().getPosX() + posX, mc.getThePlayer().getPosY(), mc.getThePlayer().getPosZ() + posZ);
                this.tickTimer.reset();
                break;
            }
            case "spartan": {
                if (!mc.getThePlayer().getOnGround() || !this.tickTimer.hasTimePassed(2) || !mc.getThePlayer().isCollidedHorizontally() || isInsideBlock && !mc.getThePlayer().isSneaking()) break;
                netHandlerPlayClient.addToSendQueue(classProvider.createCPacketPlayerPosition(mc.getThePlayer().getPosX(), mc.getThePlayer().getPosY(), mc.getThePlayer().getPosZ(), true));
                netHandlerPlayClient.addToSendQueue(classProvider.createCPacketPlayerPosition(0.5, 0.0, 0.5, true));
                netHandlerPlayClient.addToSendQueue(classProvider.createCPacketPlayerPosition(mc.getThePlayer().getPosX(), mc.getThePlayer().getPosY(), mc.getThePlayer().getPosZ(), true));
                netHandlerPlayClient.addToSendQueue(classProvider.createCPacketPlayerPosition(mc.getThePlayer().getPosX(), mc.getThePlayer().getPosY() - 0.2, mc.getThePlayer().getPosZ(), true));
                netHandlerPlayClient.addToSendQueue(classProvider.createCPacketPlayerPosition(0.5, 0.0, 0.5, true));
                netHandlerPlayClient.addToSendQueue(classProvider.createCPacketPlayerPosition(mc.getThePlayer().getPosX() + 0.5, mc.getThePlayer().getPosY(), mc.getThePlayer().getPosZ() + 0.5, true));
                double yaw = Math.toRadians(mc.getThePlayer().getRotationYaw());
                double x = -Math.sin(yaw) * 0.04;
                double z = Math.cos(yaw) * 0.04;
                mc.getThePlayer().setPosition(mc.getThePlayer().getPosX() + x, mc.getThePlayer().getPosY(), mc.getThePlayer().getPosZ() + z);
                this.tickTimer.reset();
                break;
            }
            case "clip": {
                if (!this.tickTimer.hasTimePassed(2) || !mc.getThePlayer().isCollidedHorizontally() || isInsideBlock && !mc.getThePlayer().isSneaking()) break;
                double yaw = Math.toRadians(mc.getThePlayer().getRotationYaw());
                double oldX = mc.getThePlayer().getPosX();
                double oldZ = mc.getThePlayer().getPosZ();
                for (int i = 1; i <= 10; ++i) {
                    double x = -Math.sin(yaw) * (double)i;
                    double z = Math.cos(yaw) * (double)i;
                    if (!classProvider.isBlockAir(BlockUtils.getBlock(new WBlockPos(oldX + x, mc.getThePlayer().getPosY(), oldZ + z))) || !classProvider.isBlockAir(BlockUtils.getBlock(new WBlockPos(oldX + x, mc.getThePlayer().getPosY() + 1.0, oldZ + z)))) continue;
                    mc.getThePlayer().setPosition(oldX + x, mc.getThePlayer().getPosY(), oldZ + z);
                    break;
                }
                this.tickTimer.reset();
                break;
            }
            case "aac3.5.0": {
                if (!this.tickTimer.hasTimePassed(2) || !mc.getThePlayer().isCollidedHorizontally() || isInsideBlock && !mc.getThePlayer().isSneaking()) break;
                double yaw = Math.toRadians(mc.getThePlayer().getRotationYaw());
                double oldX = mc.getThePlayer().getPosX();
                double oldZ = mc.getThePlayer().getPosZ();
                double x = -Math.sin(yaw);
                double z = Math.cos(yaw);
                mc.getThePlayer().setPosition(oldX + x, mc.getThePlayer().getPosY(), oldZ + z);
                this.tickTimer.reset();
                break;
            }
        }
        this.tickTimer.update();
    }

    @EventTarget
    public void onBlockBB(BlockBBEvent event) {
        if (mc.getThePlayer() != null && BlockUtils.collideBlockIntersects(mc.getThePlayer().getEntityBoundingBox(), block -> !classProvider.isBlockAir(block)) && event.getBoundingBox() != null && event.getBoundingBox().getMaxY() > mc.getThePlayer().getEntityBoundingBox().getMinY() && !((String)this.modeValue.get()).equalsIgnoreCase("Mineplex")) {
            IAxisAlignedBB axisAlignedBB = event.getBoundingBox();
            event.setBoundingBox(classProvider.createAxisAlignedBB(axisAlignedBB.getMaxX(), mc.getThePlayer().getEntityBoundingBox().getMinY(), axisAlignedBB.getMaxZ(), axisAlignedBB.getMinX(), axisAlignedBB.getMinY(), axisAlignedBB.getMinZ()));
        }
    }

    @EventTarget
    public void onPacket(PacketEvent event) {
        IPacket packet = event.getPacket();
        if (classProvider.isCPacketPlayer(packet)) {
            ICPacketPlayer packetPlayer = packet.asCPacketPlayer();
            if (((String)this.modeValue.get()).equalsIgnoreCase("AAC3.5.0")) {
                float yaw = (float)MovementUtils.getDirection();
                packetPlayer.setX(packetPlayer.getX() - Math.sin(yaw) * 1.0E-8);
                packetPlayer.setZ(packetPlayer.getZ() + Math.cos(yaw) * 1.0E-8);
            }
        }
    }

    @EventTarget
    private void onMove(MoveEvent event) {
        if (((String)this.modeValue.get()).equalsIgnoreCase("mineplex")) {
            if (mc.getThePlayer().isCollidedHorizontally()) {
                this.mineplexClip = true;
            }
            if (!this.mineplexClip) {
                return;
            }
            this.mineplexTickTimer.update();
            event.setX(0.0);
            event.setZ(0.0);
            if (this.mineplexTickTimer.hasTimePassed(3)) {
                this.mineplexTickTimer.reset();
                this.mineplexClip = false;
            } else if (this.mineplexTickTimer.hasTimePassed(1)) {
                double offset = this.mineplexTickTimer.hasTimePassed(2) ? 1.6 : 0.06;
                double direction = MovementUtils.getDirection();
                mc.getThePlayer().setPosition(mc.getThePlayer().getPosX() + -Math.sin(direction) * offset, mc.getThePlayer().getPosY(), mc.getThePlayer().getPosZ() + Math.cos(direction) * offset);
            }
        }
    }

    @EventTarget
    public void onPushOut(PushOutEvent event) {
        event.cancelEvent();
    }

    @Override
    public String getTag() {
        return (String)this.modeValue.get();
    }
}
