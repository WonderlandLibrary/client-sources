package com.alan.clients.module.impl.exploit.disabler;

import com.alan.clients.component.impl.player.*;
import com.alan.clients.component.impl.player.rotationcomponent.MovementFix;
import com.alan.clients.component.impl.render.NotificationComponent;
import com.alan.clients.component.impl.render.espcomponent.api.ESP;
import com.alan.clients.event.Listener;
import com.alan.clients.event.Priorities;
import com.alan.clients.event.annotations.EventLink;
import com.alan.clients.event.impl.input.MoveInputEvent;
import com.alan.clients.event.impl.input.KeyboardInputEvent;
import com.alan.clients.event.impl.input.MoveInputEvent;
import com.alan.clients.event.impl.motion.PostStrafeEvent;
import com.alan.clients.event.impl.motion.PreMotionEvent;
import com.alan.clients.event.impl.motion.PreUpdateEvent;
import com.alan.clients.event.impl.motion.StrafeEvent;
import com.alan.clients.event.impl.other.MoveEvent;
import com.alan.clients.event.impl.other.TeleportEvent;
import com.alan.clients.event.impl.other.WorldChangeEvent;
import com.alan.clients.event.impl.packet.PacketReceiveEvent;
import com.alan.clients.event.impl.packet.PacketSendEvent;
import com.alan.clients.event.impl.render.ViewBobbingEvent;
import com.alan.clients.module.impl.exploit.Disabler;
import com.alan.clients.module.impl.movement.Flight;
import com.alan.clients.module.impl.movement.LongJump;
import com.alan.clients.module.impl.movement.Speed;
import com.alan.clients.module.impl.player.Scaffold;
import com.alan.clients.util.chat.ChatUtil;
import com.alan.clients.util.player.MoveUtil;
import com.alan.clients.util.packet.PacketUtil;
import com.alan.clients.util.player.PlayerUtil;
import com.alan.clients.util.rotation.RotationUtil;
import com.alan.clients.util.vector.Vector2f;
import com.alan.clients.value.Mode;
import com.alan.clients.value.impl.BooleanValue;
import net.minecraft.client.gui.inventory.GuiInventory;
import net.minecraft.init.Blocks;
import net.minecraft.init.Items;
import net.minecraft.item.ItemStack;
import net.minecraft.network.Packet;
import net.minecraft.network.play.client.*;
import net.minecraft.network.play.server.S07PacketRespawn;
import net.minecraft.network.play.server.S08PacketPlayerPosLook;
import net.minecraft.network.play.server.S32PacketConfirmTransaction;
import net.minecraft.util.BlockPos;
import net.minecraft.util.EnumFacing;
import net.minecraft.util.Vec3;
import rip.vantage.commons.util.time.StopWatch;

import java.util.*;
import java.util.concurrent.ThreadLocalRandom;

public class WatchdogDisabler extends Mode<Disabler> {
    private float forward, strafe;
    private boolean disabled;
    private List<Short> actionNumbers;
    private StopWatch transactionStopwatch;
    private Queue<Vec3> positionQueue;
    private Queue<Packet<?>> transactionQueue;
    private Queue<Packet<?>> blinkQueue;
    private StopWatch pingStopwatch;
    private Integer tick;
    private Integer ticks;
    private boolean isSneaking;
    private boolean set;
    private boolean jump;
    private double initialY = 0;
    int time;
    private int worldChange = 0;
    private boolean checkedAfterTicks = false;
    public WatchdogDisabler(String name, Disabler parent) {
        super(name, parent);

        this.positionQueue = new ArrayDeque<>();
        this.transactionQueue = new ArrayDeque<>();
        this.pingStopwatch = new StopWatch();
        this.blinkQueue = new ArrayDeque<>();
        this.actionNumbers = new ArrayList<>();
        this.transactionStopwatch = new StopWatch();
    }

    public final BooleanValue scaffold = new BooleanValue("Strafe", this, true);
    public final BooleanValue ban = new BooleanValue("Jump", this, true);
    public final BooleanValue inventory = new BooleanValue("Inventory", this, false);

    @EventLink
    private final Listener<TeleportEvent> onTeleport = event -> {
    };
    @EventLink(value = Priorities.HIGH)
    Listener<MoveInputEvent> moveInput = event -> {
        forward = event.getForward();
        strafe = event.getStrafe();
    };



    @EventLink
    private final Listener<PreMotionEvent> PreMotionEvent = event -> {
        mc.gameSettings.ofDynamicFov = false;
        time++;
        if ((getModule(Flight.class).isEnabled() || getModule(LongJump.class).isEnabled())  && mc.thePlayer.offGroundTicks<5){
            time = -4;
            if(!mc.thePlayer.isSprinting()){
                event.setSprinting(true);
            }

        }
        switch (time) {

            case 1:
                event.setSprinting(true);
                //    ChatUtil.display("start");
                // Send the START_SPRINTING packet
                //     PacketUtil.send(new C0BPacketEntityAction(mc.thePlayer, C0BPacketEntityAction.Action.START_SPRINTING));
                // Set time to 2 to send STOP_SPRINTING in the next call

                break;

            case 2:
                event.setSprinting(false);
                //   ChatUtil.display("stop");
//ChatUtil.display("stop");
                //   mc.thePlayer.setSprinting(false);
                //       PacketUtil.send(new C0BPacketEntityAction(mc.thePlayer, C0BPacketEntityAction.Action.STOP_SPRINTING));

                // Reset time to 1 for the next cycle
                time = (int) Math.round(-(Math.random()+1));
                //   ChatUtil.display(time);
                break;

        }
        /*
        if (ban.getValue()) {
            if (!this.actionNumbers.isEmpty() && this.transactionStopwatch.finished(1000L)) {
                Collections.shuffle(this.actionNumbers);
                this.actionNumbers.forEach(action -> mc.getNetHandler().getNetworkManager().sendPacket(new C0FPacketConfirmTransaction(0, action, true)));
                this.actionNumbers.clear();
                this.disabled = true;
            }
        }

         */


        worldChange++;
        if (ban.getValue() && (mc.thePlayer.inventory.getStackInSlot(0) == null || mc.thePlayer.inventory.getStackInSlot(0).getItem() != Items.compass)) {

            if (jump && mc.thePlayer.onGround) {

                mc.thePlayer.jump();

                jump = false;
                set = true;

            } else if (mc.thePlayer.offGroundTicks >= 10 && set) {

                if (!BadPacketsComponent.bad(true, true, true, true, true) && !(getModule(Scaffold.class).isEnabled())) {
                    Random random = new Random();
                    float hitX = random.nextFloat();
                    float hitZ = random.nextFloat();
                PacketUtil.send(new C08PacketPlayerBlockPlacement(new BlockPos(mc.thePlayer.posX, mc.thePlayer.posY, mc.thePlayer.posZ), EnumFacing.UP.getIndex(), new ItemStack(Items.water_bucket), hitX, 1.0F, hitZ));
                }
                if (mc.thePlayer.offGroundTicks % 2 == 0) {

                    RotationComponent.setRotations(new Vector2f((float) (mc.thePlayer.rotationYaw - (10) + (Math.random() - 0.5) * 3), (float) (mc.thePlayer.rotationPitch)), 4, MovementFix.OFF);// Store the BlockPos in a variabl
                    event.setPosX(event.getPosX() + 0.095+Math.random()/100);
                }
            }
        }
        if (scaffold.getValue()) {
            if (Math.random()<0.2 &&  !getModule(Scaffold.class).isEnabled() &&  !getModule(Flight.class).isEnabled() &&  !getModule(LongJump.class).isEnabled()) {
                if (!BadPacketsComponent.bad(true, true, false, true, true) && !(getModule(Scaffold.class).isEnabled())) {
                    //   ChatUtil.display("send");s


                    Random random = new Random();
                    float hitX = random.nextFloat();
                    float hitZ = random.nextFloat();

                    PacketUtil.send(new C08PacketPlayerBlockPlacement(new BlockPos(mc.thePlayer.posX, mc.thePlayer.posY, mc.thePlayer.posZ), EnumFacing.UP.getIndex(), new ItemStack(Items.water_bucket), hitX, 1.0F, hitZ));
                }
            }

        }
    };

    @EventLink
    private final Listener<MoveEvent> moveEventListener = event -> {
        if (ban.getValue() && mc.thePlayer.offGroundTicks >= 10 && set) {
            event.setPosX(0); event.setPosY(0); event.setPosZ(0);
        }
    };



    @EventLink
    private final Listener<PacketReceiveEvent> packetReceiveEventListener = event -> {

        if (event.getPacket() instanceof S08PacketPlayerPosLook) {
            if (ticks != null) {
                ticks++;
                if (ticks == 25) {
                    set = false;
                    ticks = 0;
                    NotificationComponent.post("Watchdog Jump Disabler", "Automatically disabled Watchdog Jump check", 1000);
                }

            }
        }
    };

    @EventLink(value = Priorities.LOW)
    public final Listener<PreUpdateEvent> onPreUpdate = event -> {
        if (inventory.getValue() && !(getModule(Scaffold.class).isEnabled())) {
            if ( tick > 0) {
                BlinkComponent.dispatch();
                mc.getNetHandler().getNetworkManager().sendUnregisteredPacket(new C0DPacketCloseWindow(mc.thePlayer.inventoryContainer.windowId));
                tick = 0;
            } else  {
                BlinkComponent.dispatch();
            }
        }
        else{
            BlinkComponent.dispatch();
        }

        if((MoveUtil.enoughMovementForSprinting() || getModule(Speed.class).isEnabled())  && mc.gameSettings.keyBindBack.isKeyDown()){

            RotationComponent.setRotations(new Vector2f((float) Math.toDegrees(MoveUtil.direction(forward, strafe) -(float) (Math.random() * 0.1f)), mc.thePlayer.rotationPitch),
                    Math.random()*50, MovementFix.OFF);
        }
    };
    @EventLink
    private final Listener<PacketSendEvent> packetSendEventListener = event -> {
        if (inventory.getValue() && !(getModule(Scaffold.class).isEnabled())) {
            if (inventory.getValue()) {
                if (event.getPacket() instanceof C0EPacketClickWindow && ((C0EPacketClickWindow) event.getPacket()).getWindowId() == mc.thePlayer.inventoryContainer.windowId && !(mc.currentScreen instanceof GuiInventory)) {
                    BlinkComponent.blinking = true;
                    tick++;
                    event.setCancelled();
                    mc.getNetHandler().getNetworkManager().sendUnregisteredPacket(new C16PacketClientStatus(C16PacketClientStatus.EnumState.OPEN_INVENTORY_ACHIEVEMENT));
                    mc.getNetHandler().getNetworkManager().sendUnregisteredPacket(event.getPacket());


                }
            }

        }






    };

    @Override
    public void onDisable() {
        NotificationComponent.post("Watchdog Disabler","DO NOT DISABLE IN GAME OR YOU WILL BAN");
        if(time == 1){

        }  else if(time == 2){

        }
    }

    @EventLink
    public final Listener<WorldChangeEvent> onWorldChange = event -> {
        worldChange = 0;
        if (ban.getValue() ) {
            NotificationComponent.post("Watchdog Jump Disabler", "Disabling Jump check for Watchdog", 5000);
            jump = true;
            set = false;
            ticks = 0;
        }
    };


}