package xyz.cucumber.base.utils.render.shaders;

import xyz.cucumber.base.utils.render.Shader;

public class Shaders {
   public static Shader testShader = new Shader(
      "#version 120\r\n\r\nuniform float iTime;\r\n\r\nfloat gradient(float p)\r\n{\r\n    vec2 pt0 = vec2(0.00,0.0);\r\n    vec2 pt1 = vec2(0.86,0.1);\r\n    vec2 pt2 = vec2(0.955,0.40);\r\n    vec2 pt3 = vec2(0.99,1.0);\r\n    vec2 pt4 = vec2(1.00,0.0);\r\n    if (p < pt0.x) return pt0.y;\r\n    if (p < pt1.x) return mix(pt0.y, pt1.y, (p-pt0.x) / (pt1.x-pt0.x));\r\n    if (p < pt2.x) return mix(pt1.y, pt2.y, (p-pt1.x) / (pt2.x-pt1.x));\r\n    if (p < pt3.x) return mix(pt2.y, pt3.y, (p-pt2.x) / (pt3.x-pt2.x));\r\n    if (p < pt4.x) return mix(pt3.y, pt4.y, (p-pt3.x) / (pt4.x-pt3.x));\r\n    return pt4.y;\r\n}\r\n\r\nfloat waveN(vec2 uv, vec2 s12, vec2 t12, vec2 f12, vec2 h12)\r\n{\r\nvec2 x12 = sin((iTime * s12 + t12 + uv.x) * f12) * h12;\r\n\r\n    float g = gradient(uv.y / (0.2 + x12.x + x12.y));\r\n    \r\n\treturn g * 0.5;}\r\n\r\nfloat wave1(vec2 uv)\r\n{\r\n    return waveN(vec2(uv.x,uv.y-0.25), vec2(0.03,0.06), vec2(0.00,0.02), vec2(8.0,3.7), vec2(0.06,0.05));\r\n}\r\n\r\nfloat wave2(vec2 uv)\r\n{\r\n    return waveN(vec2(uv.x,uv.y-0.25), vec2(0.04,0.07), vec2(0.16,-0.37), vec2(6.7,2.89), vec2(0.06,0.05));\r\n}\r\n\r\nfloat wave3(vec2 uv)\r\n{\r\n    return waveN(vec2(uv.x,0.75-uv.y), vec2(0.035,0.055), vec2(-0.09,0.27), vec2(7.4,2.51), vec2(0.06,0.05));\r\n}\r\n\r\nfloat wave4(vec2 uv)\r\n{\r\n    return waveN(vec2(uv.x,0.75-uv.y), vec2(0.032,0.09), vec2(0.08,-0.22), vec2(6.5,3.89), vec2(0.06,0.05));\r\n}\r\n\r\nvoid main()\r\n{\r\n    vec2 uv = gl_TexCoord[0].st;\r\n    \r\n    float waves = wave1(uv) + wave2(uv) + wave3(uv) + wave4(uv);\r\n    \r\n\tfloat x = uv.x;\r\nfloat y = 0.5 - uv.y;\r\n    \r\n    vec3 bg = mix(vec3(.1,.1,.1),vec3(.04,.04,.04), (x+y)*0.5);\r\n    vec3 ac = bg + vec3(.2,.2,.2) * waves;\r\n    gl_FragColor = vec4(ac, 1.0);\r\n}"
   );
   public static Shader bloom = new Shader(
      "#version 120\r\n\r\nuniform sampler2D u_texture1;\r\nuniform sampler2D u_texture2;\r\n\r\nuniform vec2 u_direction;\r\nuniform vec2 u_texel_size;\r\n\r\nuniform float u_radius;\r\nuniform float u_saturation;\r\nuniform float u_kernel[256];\r\n\r\nvoid main(void) {\r\n\r\n    vec2 uv = gl_TexCoord[0].st;\r\n\r\n    if(u_direction.x == 0.0) {\r\n        float alpha = texture2D(u_texture2, uv).a;\r\n        if (alpha > 0.0) discard;\r\n    }\r\n\r\n    vec4 color = texture2D(u_texture1, uv);\r\n    color.a *= u_kernel[0];\r\n    color.rgb *= color.a;    for(float r = 1.0; r <= u_radius; r++) {\r\n        vec2 offset = r * u_texel_size * u_direction;\r\n\r\n    vec4 left = texture2D(u_texture1, uv - offset);\r\n    vec4 right = texture2D(u_texture1, uv + offset);        color.a += left.a * u_kernel[int(r)];\r\n        color.a += right.a * u_kernel[int(r)];\r\n\t\t   color.rgb += (left.rgb*left.a + right.rgb*right.a) * u_kernel[int(r)];    }\r\n\r\n    gl_FragColor = vec4(color.rgb / color.a, mix(color.a, 1.0 - exp(-color.a * u_saturation), step(0., u_direction.y)));\r\n}"
   );
   public static Shader bloomESP = new Shader(
      "#version 120\r\n\r\nuniform sampler2D u_texture1;\r\nuniform sampler2D u_texture2;\r\nuniform vec3 u_color, u_color2;\r\nuniform vec2 u_direction;\r\nuniform vec2 u_texel_size;\r\nuniform float u_radius;\r\nuniform int type;uniform int colorMode;uniform float sensitivity;uniform float u_time;uniform float u_kernel[256];\r\n\r\nvec3 HSBtoRGB(vec3 hsb) {\r\n    float hue = hsb.x * 360.0;\r\n    float chroma = hsb.z * hsb.y;\r\n    float hue_prime = mod(hue / 60.0, 6.0);\r\n\r\n    vec4 base_color;\r\n    base_color.r = abs(hue_prime - 3.0) - 1.0;\r\n    base_color.g = 2.0 - abs(hue_prime - 2.0);\r\n    base_color.b = 2.0 - abs(hue_prime - 4.0);\r\n\r\n    base_color.rgb = clamp(base_color.rgb, 0.0, 1.0);\r\n\r\n    vec3 rgb = (base_color.rgb - 1.0) * chroma + hsb.z;\r\n\r\n    return rgb;\r\n}\r\nfloat random (in vec2 _st) {\r\n    return fract(sin(dot(_st.xy, vec2(12.9898,78.233)))* 43758.5453123 * sin(u_time));\r\n}float rand(vec2 n) { \r\n    return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\r\n}\r\n\r\nfloat noise(vec2 p){\r\n    vec2 ip = floor(p);\r\n    vec2 u = fract(p);\r\n    u = u*u*(3.0-2.0*u);\r\n\r\n    float res = mix(\r\n        mix(rand(ip),rand(ip+vec2(1.0,0.0)),u.x),\r\n        mix(rand(ip+vec2(0.0,1.0)),rand(ip+vec2(1.0,1.0)),u.x),u.y);\r\n    return res*res;\r\n}void main(void){\r\n    \r\n    vec2 uv=gl_TexCoord[0].st;\r\n    \r\n    if(u_direction.x==0.){\r\n        float alpha=texture2D(u_texture2,uv).a;\r\n        if(alpha>0.)discard;\r\n    }\r\n    \r\n    vec4 color=texture2D(u_texture1,uv);\r\n    color.a*=u_kernel[0];\r\n\t   float off = 1.;    if(type == 1){ off = random(uv)*3.;}    if(type == 2){ off = random(uv)*3. * sin((uv.y+uv.x)*u_time + u_time * u_radius)*4.;}     for(float r=0.;r<=u_radius*off;r++){\r\n        vec2 offset=r*u_texel_size*u_direction;\r\n        \r\n\t        float kernel = 1.;\t\t   if(r > 1.) kernel = u_kernel[int(r)];        color.a+=texture2D(u_texture1,uv-offset).a*kernel*off;\r\n        color.a+=texture2D(u_texture1,uv+offset).a*kernel*off;\r\n    }\r\n    \r\n\t   vec3 final = u_color.rgb;    if(colorMode == 1) {\t\t\tfinal = HSBtoRGB(vec3(0.5*sin(((u_time*5.+(uv.y-uv.x)*20.)*20.) * 3.14159 / 180.0)+0.5,1.0,1.0));    } else if (colorMode == 2) {\t\t\tfinal = mix(u_color, u_color2, 0.5*sin(((u_time*10.+(uv.y-uv.x)*30.)*30.) * 3.14159 / 180.0)+0.5);    } else if (colorMode == 3) {\t\t\tfinal = HSBtoRGB(vec3(0.5*sin(((u_time*5.+(uv.y-uv.x)*20.)*20.) * 3.14159 / 180.0)+0.5,.5,1.0));\t   }    gl_FragColor=vec4(final, mix(0., 1-exp(-color.a*sensitivity), step(0., u_direction.y)));\r\n}"
   );
   public static Shader lineESP = new Shader(
      "#version 120uniform float u_radius;uniform float u_texture1;uniform float u_texture2;uniform vec2 u_texel_size;uniform vec2 u_direction;uniform vec3 color;uniform float u_radius;void main(void) {\tvec2 uv = gl_TexCoord[0].st;\tif(u_direction.x == 0.){\t    float alpha = texture2D(u_texture2, uv).a;\t    if (alpha > 0.0) discard;\t}\t for(float r = 0.; r < u_radius; r++){\t\tvec2 offset = f * u_texel_size * u_direction;\t\tvec4 left = texture2D(u_diffuse_sampler, uv - offset);\t\tvec4 right = texture2D(u_diffuse_sampler, uv + offset);     if(left.a > 0) discard;\t\tif(right.a > 0) discard;\t}\tgl_FragColor = vec4(color, 1.);}"
   );
   public static Shader alphaImage = new Shader(
      "#version 120\r\n\r\nuniform float alpha;\r\nuniform sampler2D texture;\r\n\r\nvoid main()\r\n{\r\n    vec2 uv = gl_TexCoord[0].st;\r\n    \r\n    vec4 color = texture2D(texture, uv);\r\n    \r\n    if(color.a == 0.){\r\n        gl_FragColor = vec4(color);\r\n        return;\r\n    }\r\n\r\n    gl_FragColor = vec4(color.rgb, alpha);\r\n}\r\n"
   );
   public static final Shader colorPicker = new Shader(
      "#version 120\r\n\r\n#ifdef GL_ES\r\nprecision mediump float;\r\n#endif\r\n\r\nuniform vec2 u_resolution;\r\nuniform float hue;\r\n\r\nvec3 HSBtoRGB(float hue, float saturation, float brightness)\r\n{\r\n    float chroma = brightness * saturation;\r\n    float huePrime = hue * 6.0;\r\n    float x = chroma * (1.0 - abs(mod(huePrime, 2.0) - 1.0));\r\n    vec3 rgbColor;\r\n\r\n    if (0.0 <= huePrime && huePrime < 1.0)\r\n        rgbColor = vec3(chroma, x, 0.0);\r\n    else if (1.0 <= huePrime && huePrime < 2.0)\r\n        rgbColor = vec3(x, chroma, 0.0);\r\n    else if (2.0 <= huePrime && huePrime < 3.0)\r\n        rgbColor = vec3(0.0, chroma, x);\r\n    else if (3.0 <= huePrime && huePrime < 4.0)\r\n        rgbColor = vec3(0.0, x, chroma);\r\n    else if (4.0 <= huePrime && huePrime < 5.0)\r\n        rgbColor = vec3(x, 0.0, chroma);\r\n    else if (5.0 <= huePrime && huePrime < 6.0)\r\n        rgbColor = vec3(chroma, 0.0, x);\r\n    else\r\n        rgbColor = vec3(0.0);\r\n\r\n    float m = brightness - chroma;\r\n    return rgbColor + vec3(m);\r\n}\r\n\r\nvoid main() {\r\n    vec2 cords =  gl_TexCoord[0].st;\r\n    gl_FragColor = vec4(HSBtoRGB(hue,cords.x,cords.y), 1.);\r\n}"
   );
   public static Shader blur = new Shader(
      "#version 120\r\n\r\nuniform sampler2D textureIn;\r\nuniform vec2 texelSize, direction;\r\nuniform float radius;\r\nuniform float weights[256];\r\n\r\nvoid main() {\r\n    vec2 uv = gl_TexCoord[0].st;    vec3 blr = texture2D(textureIn, uv).rgb * weights[0];\r\n\r\n    for (float f = 1.0; f <= radius; f++) {\r\n        blr += texture2D(textureIn, uv + f * texelSize * direction).rgb * (weights[int(abs(f))]);\r\n        blr += texture2D(textureIn, uv - f * texelSize * direction).rgb * (weights[int(abs(f))]);\r\n    }\r\n\r\n    gl_FragColor = vec4(blr, 1.0);\r\n}"
   );
   public static Shader glassEffect = new Shader(
      "#version 120\r\n\r\nuniform sampler2D u_texture1;\r\nuniform vec2 u_texel_size, u_direction;\r\nuniform float u_radius;\r\n\r\nvoid main() {\r\n\t   if (u_direction.x == 0.0) {\r\n\t        float alpha = texture2D(u_texture1, uv).a;\r\n\t        if (alpha == 0.0) discard;\r\n\t   }\r\n    vec3 blr = texture2D(u_texture1, gl_TexCoord[0].st).rgb;\r\n\r\n    for (float f = 1.0; f <= radius; f++) {\r\n        blr += texture2D(u_texture1, gl_TexCoord[0].st + f * u_texel_size * u_direction;).rgb;\r\n        blr += texture2D(u_texture1, gl_TexCoord[0].st - f * u_texel_size * u_direction;).rgb;\r\n    }\r\n\r\n    gl_FragColor = vec4(blr, 1.0);\r\n}"
   );
   public static final Shader colorSlider = new Shader(
      "#version 120\r\n\r\n#ifdef GL_ES\r\nprecision mediump float;\r\n#endif\r\n\r\nuniform vec2 u_resolution;\r\n\r\nvec3 HSBtoRGB(float hue, float saturation, float brightness)\r\n{\r\n    float chroma = brightness * saturation;\r\n    float huePrime = hue * 6.0;\r\n    float x = chroma * (1.0 - abs(mod(huePrime, 2.0) - 1.0));\r\n    vec3 rgbColor;\r\n\r\n    if (0.0 <= huePrime && huePrime < 1.0)\r\n        rgbColor = vec3(chroma, x, 0.0);\r\n    else if (1.0 <= huePrime && huePrime < 2.0)\r\n        rgbColor = vec3(x, chroma, 0.0);\r\n    else if (2.0 <= huePrime && huePrime < 3.0)\r\n        rgbColor = vec3(0.0, chroma, x);\r\n    else if (3.0 <= huePrime && huePrime < 4.0)\r\n        rgbColor = vec3(0.0, x, chroma);\r\n    else if (4.0 <= huePrime && huePrime < 5.0)\r\n        rgbColor = vec3(x, 0.0, chroma);\r\n    else if (5.0 <= huePrime && huePrime < 6.0)\r\n        rgbColor = vec3(chroma, 0.0, x);\r\n    else\r\n        rgbColor = vec3(0.0);\r\n\r\n    float m = brightness - chroma;\r\n    return rgbColor + vec3(m);\r\n}\r\n\r\nvoid main() {\r\n    vec2 cords =  gl_TexCoord[0].st;\r\n    gl_FragColor=vec4(HSBtoRGB(cords.x,1.,1.0),1.);\r\n}"
   );
}
