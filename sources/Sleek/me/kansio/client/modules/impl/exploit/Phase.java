package me.kansio.client.modules.impl.exploit;

import com.google.common.eventbus.Subscribe;
import me.kansio.client.event.impl.*;
import me.kansio.client.modules.api.ModuleCategory;
import me.kansio.client.modules.api.ModuleData;
import me.kansio.client.modules.impl.Module;
import me.kansio.client.modules.impl.player.HackerDetect;
import me.kansio.client.value.value.BooleanValue;
import me.kansio.client.value.value.ModeValue;
import me.kansio.client.value.value.NumberValue;
import me.kansio.client.utils.math.Stopwatch;
import me.kansio.client.utils.network.PacketUtil;
import me.kansio.client.utils.player.PlayerUtil;
import net.minecraft.block.Block;
import net.minecraft.block.BlockAir;
import net.minecraft.block.BlockHopper;
import net.minecraft.network.play.client.C03PacketPlayer;
import net.minecraft.network.play.server.S02PacketChat;
import net.minecraft.network.play.server.S08PacketPlayerPosLook;
import net.minecraft.util.AxisAlignedBB;
import net.minecraft.util.BlockPos;
import net.minecraft.util.MathHelper;

import java.util.Objects;

@ModuleData(
        name = "Phase",
        category = ModuleCategory.EXPLOIT,
        description = "Allows you to clip through walls"
)
public class Phase extends Module {

    private ModeValue modeValue = new ModeValue("Mode", this, "Vanilla", "Skip", "Packetless", "Old", "BlocksMC (VClip)");
    private NumberValue<Float> distance = new NumberValue<>("Distance", this, 2F, 0.5F, 5F, 0.1F);
    private BooleanValue sneak = new BooleanValue("Sneak", this, true);

    Stopwatch timer;
    private int moveUnder;


    @Subscribe
    public void onTick(TickEvent event) {
        if (mc.thePlayer == null) return;
        if ("Vanilla".equals(modeValue.getValue())) {
            if (sneak.getValue() && !mc.thePlayer.isSneaking()) return;
            if (mc.thePlayer != null && moveUnder == 1) {
                mc.thePlayer.sendQueue.getNetworkManager().sendPacket(new C03PacketPlayer.C04PacketPlayerPosition(mc.thePlayer.posX, mc.thePlayer.posY - 2.0, mc.thePlayer.posZ, false));
                mc.thePlayer.sendQueue.getNetworkManager().sendPacket(new C03PacketPlayer.C04PacketPlayerPosition(Float.NEGATIVE_INFINITY, Float.NEGATIVE_INFINITY, Float.NEGATIVE_INFINITY, true));
                moveUnder = 0;
            }
            if (mc.thePlayer != null && moveUnder == 1488) {
                double mx = -Math.sin(Math.toRadians(mc.thePlayer.rotationYaw));
                double mz = Math.cos(Math.toRadians(mc.thePlayer.rotationYaw));
                double x = mc.thePlayer.movementInput.moveForward * mx + mc.thePlayer.movementInput.moveStrafe * mz;
                double z = mc.thePlayer.movementInput.moveForward * mz - mc.thePlayer.movementInput.moveStrafe * mx;
                mc.thePlayer.sendQueue.getNetworkManager().sendPacket(new C03PacketPlayer.C04PacketPlayerPosition(mc.thePlayer.posX + x, mc.thePlayer.posY, mc.thePlayer.posZ + z, false));
                mc.thePlayer.sendQueue.getNetworkManager().sendPacket(new C03PacketPlayer.C04PacketPlayerPosition(Float.NEGATIVE_INFINITY, mc.thePlayer.posY, Float.NEGATIVE_INFINITY, true));
                moveUnder = 0;
            }
        }
    }

    @Subscribe
    public void onMove(MoveEvent event) {
        if (Objects.equals(modeValue.getValue(), "Vanilla")) {
            if (sneak.getValue() && !mc.thePlayer.isSneaking()) return;
            if (isInsideBlock()) {
                if (mc.gameSettings.keyBindJump.isKeyDown()) {
                    event.setMotionY(mc.thePlayer.motionY = 0.5);
                } else if (mc.gameSettings.keyBindSneak.isKeyDown()) {
                    event.setMotionY(mc.thePlayer.motionY = -0.5);
                } else {
                    event.setMotionY(mc.thePlayer.motionY = 0.0);
                }
                PlayerUtil.setMotion(event, distance.getValue());
            }
        }
    }

    @Subscribe
    public void onPacket(PacketEvent event) {
        if (modeValue.getValue().equals("Vanilla"))  {
            if (event.getPacket() instanceof S08PacketPlayerPosLook) {
                if (moveUnder == 2) {
                    moveUnder = 1;
                } else if (moveUnder == 69) {
                    moveUnder = 1488;
                }
            }
        }

        if (modeValue.getValue().contains("Blocks")) {
            if (event.getPacket() instanceof S02PacketChat) {
                S02PacketChat packet = event.getPacket();
                String msg = packet.getChatComponent().getFormattedText();

                if (msg.contains("Cages open in:")) {
                    if (sneak.getValue()) {
                        if (!mc.gameSettings.keyBindSneak.pressed)
                            return;
                    }

                    Block block = mc.theWorld.getBlockState(new BlockPos(mc.thePlayer.posX, mc.thePlayer.posY - 1, mc.thePlayer.posZ)).getBlock();


                    if (block.getLocalizedName().toLowerCase().contains("glass") || mc.gameSettings.keyBindSneak.pressed && !block.getLocalizedName().toLowerCase().contains("air")) {
                        HackerDetect.getInstance().setCageYValue(mc.thePlayer.posY);
                        mc.thePlayer.setPosition(mc.thePlayer.posX, mc.thePlayer.posY - 3, mc.thePlayer.posZ);
                    }
                }
            }
        }
    }
    
    @Subscribe
    public void onCollide(BlockCollisionEvent event) {
        if (modeValue.getValue().equals("Vanilla")) {
            if (sneak.getValue() && !mc.thePlayer.isSneaking()) return;
            if (mc.thePlayer.isCollidedHorizontally && !isInsideBlock()) {
                double mx = -Math.sin(Math.toRadians(mc.thePlayer.rotationYaw));
                double mz = Math.cos(Math.toRadians(mc.thePlayer.rotationYaw));
                double x = mc.thePlayer.movementInput.moveForward * mx + mc.thePlayer.movementInput.moveStrafe * mz;
                double z = mc.thePlayer.movementInput.moveForward * mz - mc.thePlayer.movementInput.moveStrafe * mx;
                event.setAxisAlignedBB(null);
                mc.thePlayer.setPosition(mc.thePlayer.posX + x,mc.thePlayer.posY,mc.thePlayer.posZ + z);
                moveUnder = 69;
            }
            if (isInsideBlock()) event.setAxisAlignedBB(null);
        }
    }

    @Subscribe
    public void event(UpdateEvent event) {
        double[] forward = PlayerUtil.teleportForward(distance.getValue());
        if (sneak.getValue() && mc.thePlayer.isSneaking() || !sneak.getValue()) {
            switch (modeValue.getValue()) {
                case "Old": {
                    if (mc.thePlayer.isCollidedHorizontally) {
                        PacketUtil.sendPacketNoEvent(new C03PacketPlayer.C04PacketPlayerPosition(mc.thePlayer.posX + forward[0], mc.thePlayer.posY, mc.thePlayer.posZ + forward[1], true));
                        PacketUtil.sendPacketNoEvent(new C03PacketPlayer.C04PacketPlayerPosition(mc.thePlayer.posX + forward[0], mc.thePlayer.posY - 256, mc.thePlayer.posZ + forward[1], true));
                        mc.thePlayer.setPosition(mc.thePlayer.posX + forward[0], mc.thePlayer.posY, mc.thePlayer.posZ + forward[1]);
                    }

                    if (isInsideBlock()) {
                        event.setOnGround(true);
                        PlayerUtil.setMotion(distance.getValue());
                        mc.thePlayer.motionY = mc.thePlayer.movementInput.jump ? distance.getValue() / 2 : mc.thePlayer.movementInput.sneak ? -distance.getValue() / 2 : 0;
//                            } else if (mc.thePlayer.movementInput.sneak) {
//                                PacketUtil.sendPacketNoEvent(new C03PacketPlayer.C04PacketPlayerPosition(mc.thePlayer.posX, mc.thePlayer.posY + 256, mc.thePlayer.posZ, true));
//                                PacketUtil.sendPacketNoEvent(new C03PacketPlayer.C04PacketPlayerPosition(mc.thePlayer.posX, mc.thePlayer.posY, mc.thePlayer.posZ, true));
//                                mc.thePlayer.setPosition(mc.thePlayer.posX, mc.thePlayer.posY - 0.0625, mc.thePlayer.posZ);
                    }
                    break;
                }
                case "Packetless": {
                    if (mc.thePlayer.isCollidedHorizontally) {
                        mc.thePlayer.setPosition(mc.thePlayer.posX + forward[0] / 4, mc.thePlayer.posY, mc.thePlayer.posZ + forward[1] / 4);
                    }
                    break;
                }

                case "Skip": {
                    if (mc.thePlayer.isCollidedHorizontally) {
                        PacketUtil.sendPacketNoEvent(new C03PacketPlayer.C04PacketPlayerPosition(mc.thePlayer.posX + PlayerUtil.teleportForward(0.005F)[0], mc.thePlayer.posY, mc.thePlayer.posZ + PlayerUtil.teleportForward(0.005F)[1], true));
                        mc.thePlayer.setPosition(mc.thePlayer.posX + PlayerUtil.teleportForward(0.005F)[0], mc.thePlayer.posY, mc.thePlayer.posZ + PlayerUtil.teleportForward(0.005F)[1]);
                    }

                    if (isInsideBlock()) {
                        PacketUtil.sendPacketNoEvent(new C03PacketPlayer.C04PacketPlayerPosition(mc.thePlayer.posX + 1.5 * Math.cos(Math.toRadians(mc.thePlayer.rotationYaw + 90.0F)), mc.thePlayer.posY, mc.thePlayer.posZ + 1.5 * Math.sin(Math.toRadians(mc.thePlayer.rotationYaw + 90.0F)), true));
                        mc.thePlayer.boundingBox.offsetAndUpdate(1.5 * Math.cos(Math.toRadians(mc.thePlayer.rotationYaw + 90.0F)), 0.0D, 1.5 * Math.sin(Math.toRadians(mc.thePlayer.rotationYaw + 90.0F)));
                    }
                    break;
                }
                case "Vanilla": {
                    if (mc.gameSettings.keyBindSneak.isPressed() && !isInsideBlock()) {
                        mc.thePlayer.sendQueue.getNetworkManager().sendPacket(new C03PacketPlayer.C04PacketPlayerPosition(mc.thePlayer.posX, mc.thePlayer.posY - 2.0, mc.thePlayer.posZ, true));
                        moveUnder = 2;
                    }
                    break;
                }
                case "BlocksMC (VClip)": {
                    if (sneak.getValue()) {
                        if (!mc.gameSettings.keyBindSneak.pressed)
                            return;
                    }

                    Block block = mc.theWorld.getBlockState(new BlockPos(mc.thePlayer.posX, mc.thePlayer.posY - 1, mc.thePlayer.posZ)).getBlock();


                    if (block.getLocalizedName().toLowerCase().contains("glass") || (mc.gameSettings.keyBindSneak.pressed && mc.thePlayer.ticksExisted % 5 == 0)) {
                        if (mc.thePlayer.onGround) {
                            mc.thePlayer.setPosition(mc.thePlayer.posX, mc.thePlayer.posY - 3, mc.thePlayer.posZ);
                        }
                    }


                    break;
                }
            }
        }
    }

    private boolean isInsideBlock() {
        try {
            for (int x = MathHelper.floor_double(
                    mc.thePlayer.getEntityBoundingBox().minX); x < MathHelper.floor_double(mc.thePlayer.getEntityBoundingBox().maxX) + 1; ++x) {
                for (int y = MathHelper.floor_double(
                        mc.thePlayer.getEntityBoundingBox().minY + 1.0D); y < MathHelper.floor_double(mc.thePlayer.getEntityBoundingBox().maxY)
                        + 2; ++y) {
                    for (int z = MathHelper.floor_double(
                            mc.thePlayer.getEntityBoundingBox().minZ); z < MathHelper.floor_double(mc.thePlayer.getEntityBoundingBox().maxZ)
                            + 1; ++z) {
                        Block block = mc.theWorld.getBlockState(new BlockPos(x, y, z)).getBlock();
                        if (block != null && !(block instanceof BlockAir)) {
                            AxisAlignedBB boundingBox = block.getCollisionBoundingBox(mc.theWorld, new BlockPos(x, y, z),
                                    mc.theWorld.getBlockState(new BlockPos(x, y, z)));
                            if (block instanceof BlockHopper) {
                                boundingBox = new AxisAlignedBB(x, y, z, x + 1, y + 1, z + 1);
                            }

                            if (boundingBox != null && mc.thePlayer.getEntityBoundingBox().intersectsWith(boundingBox))
                                return true;
                        }
                    }
                }
            }
            return false;
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
    }

    @Override
    public String getSuffix() {
        return modeValue.getValueAsString();
    }
}
